function [newpos] = posinterp(posdata, varargin)
% |  _ \ ___  ___  |_ _|_ __ | |_ ___ _ __ _ __  
% | |_) / _ \/ __|  | || '_ \| __/ _ \ '__| '_ \ 
% |  __/ (_) \__ \  | || | | | ||  __/ |  | |_) |
% |_|   \___/|___/ |___|_| |_|\__\___|_|  | .__/ 
%                                         |_|    
% newpos = POSINTERP(posdata, options)
%          posinterp returns interpolated position and direction data
%          where posdata is a position structure from readpos() and
%               options take the form 'option', value, 'option', value, ...
%
%    'diode' - 1 if only front diode is used for pos, and 0
%                if only back is used.  'diode' can be any
%                value in between 0 and 1, in which case the
%                final pos will be calculated as the specified
%                ratio between the front and back diodes
%                (default 0.5, i.e. average of the diodes)
%
%    'reversex' 1 for reversing flipping the pos image in x
%
%    'reversey' 1 for reversing flipping the pos image in y

%    'bounds' - a two by two array giving the bounds of the
%               environment (all points outside the bounds are
%               discarded) (default - all points included)
%
%    'maxv'   - the maximum velocity allowed (default infinity)
%
%    'maxdevpoints' - the maximum number of points
%               between two high velocity pairs that are to be
%               zeroed out (default 10)
%
%    'pinterp' 1 for position interpoloation  (default 1)
%
%    'maxpinterp' is the maximum number of missing points to be
%                 interpolated over (default inf)
%
%    'maxdinterp' - the maximum distance (in pixels) to be
%                  interpolated over (default infinity)
%
%newpos is a structure with Opt (struct of options, formerly arglist), description, field, and data elements
%
% Notes
% ------
% MCZ EDIT- ADD OPTION TO RUN CODE WITH ONLY ONE "DIODE" / MARKER. MIGHT
% STILL NEED SOME DEBUGGING IN ALL CASES. diodenum addition to varargin
% possibilities
%
%
% 12/20/2016 added code to deal with jumps in timestamps from old SJ5 data.
% Last timestamp in repeat timestamps kept, remainder excised.
% Tested with SJ5, worked
%
% 08/01/2020 : Ryan majorly modified this for rawpos generated by deeplabcut
%
% Left - right or front back now computed as the first two points with "left"
% and "right"s or "front" and "back"  in their name labels. This should be the
% head. A flag toggles the ability to determine the primary point as the
% average of many left/right points.

ip = inputParser;
ip.KeepUnmatched = true;
ip.StructExpand  = true;
ip.addParameter('directionPoints',{});
ip.addParameter('pointvalid',-1);         % Assume all points are valid for locating the animal by defautl, or pick the point name
ip.addParameter('midpoint', 0.5);         % use average between front-back or left-right points
ip.addParameter('bounds', ...
    [-1e100 -1e100 ; 1e100 1e100]);       % no Opt.bounds
ip.addParameter('maxv', 1e100);           % allow any velocity
ip.addParameter('maxdevpoints', 10);
ip.addParameter('maxpinterp', 1e100);     % allow interpolation of any number of points
ip.addParameter('maxdinterp', 1e100);     % allow interpolation over any distance
ip.addParameter('reversex',       false); % don't flip pos along x
ip.addParameter('reversey',       false);
ip.addParameter('pinterp',        true);  % do interpolate
ip.addParameter('globalCentroid', false);
ip.parse(varargin{:})
Opt = ip.Results;

newpos.data = [];
if isempty(posdata.data)
    return
else
    % Put all of the arguments into the new pos struct!
    newpos.Opt = Opt;
end

% Write out the command parameters to a string
% --------------------------------------------
newpos.descript = posdata.descript;
descript = sprintf('interpolated position data from %s structure', inputname(1));
newpos.descript{end+1,1} = descript;
newpos.fields = 'time x y direction';
newpos.units = posdata.units;
newpos.cmperpixel = posdata.cmperpixel;

% Compute the set of right-left or front-back points whose midpoint will
% constitute the animal's true location
header = posdata.dataheader;
pointNames = header(1,:);
pointTypes = header(2,:);
points_x = find(pointTypes == "x");
points_y = find(pointTypes == "y");
assert( numel(points_x) == numel(points_y),...
    'Error: You must have an x and y  value for each point')
[uPoints,  ~,  iUpoints] = unique(pointNames(pointNames ~= "timestamp"));

% ============ Indivdual point-wiseoperations ==================================
% now interpolate the Opt.diode position(s).  when i = 1, the for loop
% interpolates the front Opt.diode position.  when i = 2, the for loop
% interpolates the back Opt.diode position.
pos = [];
time = posdata.data(:, pointNames == "timestamp");
iPnt = 0;
for point = uPoints

    iPnt = iPnt + 1;

    x = pointTypes == "x" & pointNames == point;
    y = pointTypes == "y" & pointNames == point;

    % SHORTCUT/ALIASES
    X = 1;
    Y = 2;
    I = 3;
    UPPER = 2;
    LOWER = 1;

    % save current Opt.diode positions into tmppos
    tmppos = posdata.data(:,x | y);
    % emed indices
    tmppos(:,I) = 1:size(posdata.data,1);

    % if Opt.reversex is 1, then flip the pos along x
    if Opt.reversex
        tmppos(:,X) = 320 - tmppos(:,X) + 1;
    end
    if Opt.reversey
        tmppos(:,Y) = 240 - tmppos(:,Y) + 1;
    end

    % Get an index of all points that lie outside the valid boundary and
    % set those points to (0,0)
    indout = tmppos(:,X) > Opt.bounds(UPPER,X) | tmppos(:,X) < Opt.bounds(LOWER,X) | ...
        tmppos(:,Y) > Opt.bounds(UPPER,Y) | tmppos(:,Y) < Opt.bounds(LOWER,Y);
    tmppos(indout,[X Y]) = 0;

    % Find all valid (non-zero in both x and y) positions
    indvalid = find(prod(tmppos,2));

    % Identify all points representing "unreasonable" velocities and set
    % them to zero
    vel = euc_dist(tmppos(indvalid(1:end-1),[X Y]), tmppos(indvalid(2:end),[X Y])) ./ ...
        (time(indvalid(2:end)) - time(indvalid(1:end-1)));
    indtoofast = find(vel > Opt.maxv);
    fprintf('\n Found %d points with velocity higher than vel=%2.2f allows\n', numel(indtoofast), Opt.maxv);

    % Zero out both the x and y positions from the toofast points
    indtoofastpos = indvalid(indtoofast+1);
    tmppos(indtoofastpos,[X Y]) = 0;

    % Find all pairs of "toofast" points less than Opt.maxdevpoints apart
    % any two points close together and both associated with a high velocity
    % come from tracker artifacts where the wrong point is tracked for a few samples
    % first figure out how many points separate each pair of toofast points
    % then identify the ones that are closer than Opt.maxdevpoints
    indpairs = find(diff(indtoofastpos) < Opt.maxdevpoints);
    fprintf('\n Found %d points that are faster than maxdevpoints=%d allows\n', numel(indpairs), Opt.maxdevpoints);
    % zero out the pos values between these pairs
    for k = 1:length(indpairs)
        tmppos(indtoofastpos(indpairs(k)):indtoofastpos(indpairs(k)+1),[X Y]) = 0;
    end

    if Opt.pinterp
        % after the changes made above, find the new set of valid and invalid
        % pos points
        tmp = prod(tmppos,2);
        indvalid = find(tmp);
        indzeros = find(~tmp);

        % only look at those positions between first valid and last valid
        indzeros = indzeros(indzeros > indvalid(1) & indzeros < indvalid(end));
        % go through the list and calculate the length of each interpolated segment
        % and the distances to be interpolated over
        j = 1;
        while j < length(indzeros)
            % the first valid position is pos(zeropos(j) - 1)
            startpos = tmppos(indzeros(j)-1, [X Y]);
            startindex = j;
            % go though and find the whole list of consecutive zeros
            while j < length(indzeros) && (indzeros(j+1) - indzeros(j)) == 1
                j = j + 1;
            end
            % the end point is the next point after the current zero
            endpos = tmppos(indzeros(j)+1,[X Y]);
            % if either the distance to be interpolated over or the number of
            % points is too large, don't interpolated over them
            d = euc_dist(startpos, endpos);
            if d > Opt.maxdinterp || (j-startindex+1) > Opt.maxpinterp
                indzeros(startindex:j) = -1;
            else
                % put d into the list of interpdists and the difference between the
                % indeces into interppoints
            end
            j = j + 1;
        end

        % cut out the negative ones from the list of zeropos
        indzeros = indzeros(indzeros ~= -1);

        % get the list of times where interpolation should be done
        interptimes = time(indzeros);

        % interpolate over the x and y coordinates
        if ~isempty(interptimes)
            
            % CHECK for timestamp jumps! edge case in old data (SJ5) % mcz
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % catches adjacent duplications, NaNs all but the last, then
            % then excises all NaNs [handles adjacent duplications only]
            relTimeSeg=time(indvalid);
            [n, bin] = histc(relTimeSeg, unique(relTimeSeg));
            multiple = find(n > 1);
            index    = find(ismember(bin, multiple));
            if  ~isempty(index)
                temp = NaN(size(relTimeSeg(index)));
                [~,ia,~]=unique(relTimeSeg(index),'last');
                temp(ia) = relTimeSeg(index(ia));
                relTimeSeg(index)=temp;
                indvalid_new = find(~isnan(relTimeSeg));
                time(indvalid(indvalid_new))=relTimeSeg(indvalid_new);

                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                tmppos(indzeros,X) = round(interp1(time(indvalid(indvalid_new)), ...
                    tmppos(indvalid(indvalid_new), X), interptimes));
                tmppos(indzeros,Y) = round(interp1(time(indvalid(indvalid_new)), ...
                    tmppos(indvalid(indvalid_new), Y), interptimes));
            else
               tmppos(indzeros,X) = round(interp1(time(indvalid), ...
                tmppos(indvalid, X), interptimes));
               tmppos(indzeros,Y) = round(interp1(time(indvalid), ...
                    tmppos(indvalid, Y), interptimes));
            end
        end
    end

    % save this interpolated pos
    pos(:,[find(x) find(y)]) = tmppos(:, [X Y]);
    inds = tmppos(:,3);

end  % end invidual point computation

% ============ Gestalt point operations ==================================
% find the valid pos's according to the 'Opt.diode' variable
if ischar(Opt.pointvalid) || isstring(Opt.pointvalid) || iscellstr(Opt.pointvalid)
    Opt.pointvalid = string(Opt.pointvalid);
    pointinds = ismember(pointNames, Opt.pointvalid);
    indvalidpos = find(prod(pos(:,pointinds),2));
else
    indvalidpos = find(prod(pos(:,2:end),2));
end

% get the indeces of the first and last valid pos
pvalidfirst = indvalidpos(1);
pvalidlast  = indvalidpos(end);

% truncate pos if there are zeros at the beginning and end
pos  = pos(pvalidfirst:pvalidlast, :);
time = time(pvalidfirst:pvalidlast,1);
inds = inds(pvalidfirst:pvalidlast,1);

%====== DETERMINE WHICH POINTS FOR LEFT-RIGHT OR FRONT-BACK DIRECTION ===========
% Now we need to focus on direction, and to do so, identify which two points
% will form the animalk's direction
moreThanOnePoint = size(pos,2)-1 > 2; %More than just a single x,y tuple?
if moreThanOnePoint
    % IF user does not specify points that constitute direction, then find the first  front-back or left-rigth pair
    if isempty(Opt.directionPoints)
        % Determine if front-back or left-right exist
        if any(contains(pointNames, "front")) && any(contains(pointNames,"back"))
            pairPoints = 'front-back';
            P1 = pointNames(find(pointNames == "front",1,'first'));
            P2 = pointNames(find(pointNames == "back",1,'first'));
        elseif any(contains(pointNames, "left")) && any(contains(pointNames,"right"))
            pairPoints = 'left-right';
            P1 = pointNames(find(contains(pointNames,"left"),  1, 'first'));
            P2 = pointNames(find(contains(pointNames,"right"), 1, 'first'));
        else
            pairPoints = 'improper  type';
        end
    % Else the use has given points
    else
        Opt.directionPoints = string(Opt.directionPoints);
        P1 = Opt.directionPoints(1);
        P2 = Opt.directionPoints(2);
        % Has the user provided a type for these points?
        if isempty(Opt.directionPointType)
            if contains(P1,'front')
                pairPoints = 'front-back';
            elseif contains(P1,'left')
                pairPoints = 'left-right';
            else
                pairPoints = 'improper type';
            end
        else
            pairPoints = Opt.directionPointType;
        end
    end
else
    pairPoints = 'singular';
end

%====== COMPUTE THE UNDERLYING DIRECTION BASED ON THOSE POINTS ==================
% Compute direction based on front-back or left-right leds
switch pairPoints
case {'front-back', 'left-right'}
    [P1_x, P1_y, P2_x, P2_y ] = deal(pointNames==P1 & pointTypes == "x",...
                                     pointNames==P1 & pointTypes == "y",...
                                     pointNames==P2 & pointTypes == "x",...
                                     pointNames==P2 & pointTypes == "y");
    if strcmp(pairPoints,'front-back')
        rotation_correction = 0;
    else
        rotation_correction = -pi/2; % rotate our vector -90 degrees to align with front-back
    end
    direction = atan2(pos(:,P1_x)-pos(:,P2_x), pos(:,P1_y)-pos(:,P2_y)) ...
                + rotation_correction;
case 'singular'
    direction = atan2(pos(:,pointNames~="timestamp" & pointTypes == "x"), ...
                      pos(:,pointNames~="timestamp" & pointTypes == "y"));
case 'improper type'
    disp('');
    error("ERROR: More than 1 point in deepLabCut, but cannot identify front-back or left-right points.  Please provide 'directionPointType' in your varargin");
end

% if the 'Opt.diode' variable was 1 or 0, then only the front or back Opt.diode,
% respectively, needed to be valid for pos.  for directions, however, both
% diodes should be valid, so do an additional check to see that both diodes
% were valid.
if ~isempty(Opt.midpoint) && Opt.midpoint>0 && Opt.midpoint<1
    indzerodir = find(~prod(pos(:,2:end),2));
    direction(indzerodir) = -10;
end

% now compute the final output pos, which can be anywhere including and
% between the front and back diodes.  this pos is determined by the 'Opt.diode'
% variable, with 0 being the back Opt.diode, 1 being the front Opt.diode, and any
% value in between being the proportionate distance between the two
if ~isempty(Opt.midpoint) && moreThanOnePoint
    pos(:,2) = pos(:,P1_x) + Opt.midpoint * (pos(:,P2_x)-pos(:,P1_x));
    pos(:,3) = pos(:,P1_y) + Opt.midpoint * (pos(:,P2_y)-pos(:,P2_y));
    pos = pos(:,2:3);
else
    pos = pos(:,2:end);
end

% take all of the valid position samples and the corresponding set of direction
% samples and save for the output
newpos.data = [time pos direction];
newpos.rawposInds = inds;
newpos.likelihood = posdata.likelihood(inds,2:end);
newpos.likelihoodheader = posdata.likelihoodheader(:,2:end);
