function [newpos] = posinterpSimple(posdata, varargin)
% Simple posinterp developed from seeing that the pos interp file was less  accurate
% than the actual raw position as computed by deep lab cut. So i'm removing the
% post-processing done here. There may still be a point or two in a video that jump off the
% track but the normal jlab pos algorithm  erroneously smooths over actualy position variation
% and sometimes smooths the animals position over the corner of the open field, whereas DLC
% never makes that mistake.
%
% Some of these flags will not work below
%
% newpos = POSINTERP(posdata, options)
%          posinterp returns interpolated position and direction data
%          where posdata is a position structure from readpos() and
%               options take the form 'option', value, 'option', value, ...
%
%    'diode' - 1 if only front diode is used for pos, and 0
%                if only back is used.  'diode' can be any
%                value in between 0 and 1, in which case the
%                final pos will be calculated as the specified
%                ratio between the front and back diodes
%                (default 0.5, i.e. average of the diodes)
%
%    'reversex' 1 for reversing flipping the pos image in x
%
%    'reversey' 1 for reversing flipping the pos image in y

%    'bounds' - a two by two array giving the bounds of the
%               environment (all points outside the bounds are
%               discarded) (default - all points included)
%
%    'maxv'   - the maximum velocity allowed (default infinity)
%
%    'maxdevpoints' - the maximum number of points
%               between two high velocity pairs that are to be
%               zeroed out (default 10)
%
%    'pinterp' 1 for position interpoloation  (default 1)
%
%    'maxpinterp' is the maximum number of missing points to be
%                 interpolated over (default inf)
%
%    'maxdinterp' - the maximum distance (in pixels) to be
%                  interpolated over (default infinity)
%
%newpos is a structure with Opt (struct of options, formerly arglist), description, field, and data elements
%
% Notes
% ------
%
% 08/01/2020 : Ryan majorly modified this for rawpos generated by deeplabcut
%
% Left - right or front back now computed as the first two points with "left"
% and "right"s or "front" and "back"  in their name labels. This should be the
% head. A flag toggles the ability to determine the primary point as the
% average of many left/right points.

ip = inputParser;
ip.KeepUnmatched = true;
ip.StructExpand  = true;
ip.addParameter('directionPoints',{});
ip.addParameter('pointvalid',-1);         % Assume all points are valid for locating the animal by defautl, or pick the point name
ip.addParameter('midpoint', 0.5);         % use average between front-back or left-right points
ip.addParameter('bounds', ...
    [-1e100 -1e100 ; 1e100 1e100]);       % no Opt.bounds
ip.addParameter('maxv', 1e100);           % allow any velocity
ip.addParameter('maxdevpoints', 10);
ip.addParameter('maxpinterp', 1e100);     % allow interpolation of any number of points
ip.addParameter('maxdinterp', 1e100);     % allow interpolation over any distance
ip.addParameter('reversex',       false); % don't flip pos along x
ip.addParameter('reversey',       false);
ip.addParameter('pinterp',        true);  % do interpolate
ip.addParameter('globalCentroid', false);
ip.parse(varargin{:})
Opt = ip.Results;

warn = "";

newpos.data = [];
if isempty(posdata.data)
    return
else
    % Put all of the arguments into the new pos struct!
    newpos.Opt = Opt;
end

% Write out the command parameters to a string
% --------------------------------------------
newpos.descript = posdata.descript;
descript = sprintf('interpolated position data from %s structure', inputname(1));
newpos.descript{end+1,1} = descript;
newpos.fields = 'time x y direction';
newpos.units = posdata.units;
newpos.cmperpixel = posdata.cmperpixel;

% Compute the set of right-left or front-back points whose midpoint will
% constitute the animal's true location
header = posdata.dataheader;
pointNames = header(1,:);
pointTypes = header(2,:);
points_x = find(pointTypes == "x");
points_y = find(pointTypes == "y");
assert( numel(points_x) == numel(points_y),...
    'Error: You must have an x and y  value for each point')
[uPoints,  ~,  iUpoints] = unique(pointNames(pointNames ~= "timestamp"));

% ============ Indivdual point-wiseoperations ==================================
% now interpolate the Opt.diode position(s).  when i = 1, the for loop
% interpolates the front Opt.diode position.  when i = 2, the for loop
% interpolates the back Opt.diode position.
pos = [];
time = posdata.data(:, pointNames == "timestamp");
iPnt = 0;
for point = uPoints

    iPnt = iPnt + 1;

    x = pointTypes == "x" & pointNames == point;
    y = pointTypes == "y" & pointNames == point;

    % SHORTCUT/ALIASES
    X = 1;
    Y = 2;
    I = 3;
    UPPER = 2;
    LOWER = 1;

    % save current Opt.diode positions into tmppos
    tmppos = posdata.data(:,x | y);
    % emed indices
    tmppos(:,I) = 1:size(posdata.data,1);

    % if Opt.reversex is 1, then flip the pos along x
    if Opt.reversex
        tmppos(:,X) = 320 - tmppos(:,X) + 1;
    end
    if Opt.reversey
        tmppos(:,Y) = 240 - tmppos(:,Y) + 1;
    end

    % Get an index of all points that lie outside the valid boundary and
    % set those points to (0,0)
    indout = tmppos(:,X) > Opt.bounds(UPPER,X) | tmppos(:,X) < Opt.bounds(LOWER,X) | ...
        tmppos(:,Y) > Opt.bounds(UPPER,Y) | tmppos(:,Y) < Opt.bounds(LOWER,Y);
    tmppos(indout,[X Y]) = nan;

    % Find all valid (non-zero in both x and y) positions
    indvalid = find(prod(tmppos,2));

    % Identify all points representing "unreasonable" velocities and set
    % them to zero
    vel = euc_dist(tmppos(indvalid(1:end-1),[X Y]), tmppos(indvalid(2:end),[X Y])) ./ ...
        (time(indvalid(2:end)) - time(indvalid(1:end-1)));
    indtoofast = find(vel > Opt.maxv);
    fprintf('\n Found %d (%2.1f%%) points with velocity higher than vel=%2.2f allows\n', numel(indtoofast), 100*numel(indtoofast)/size(tmppos,1), Opt.maxv);

    % Zero out both the x and y positions from the toofast points
    indtoofastpos = indvalid(indtoofast+1);
    tmppos(indtoofastpos,[X Y]) = nan;

    % Find all pairs of "toofast" points less than Opt.maxdevpoints apart
    % any two points close together and both associated with a high velocity
    % come from tracker artifacts where the wrong point is tracked for a few samples
    % first figure out how many points separate each pair of toofast points
    % then identify the ones that are closer than Opt.maxdevpoints
    indpairs = find(diff(indtoofastpos) < Opt.maxdevpoints);
    fprintf('\n Found %d (%2.1f) points that are faster than maxdevpoints=%d allows\n', numel(indpairs), 100*numel(indpairs)/size(tmppos,1), Opt.maxdevpoints);
    % zero out the pos values between these pairs
    for k = 1:length(indpairs)
        tmppos(indtoofastpos(indpairs(k)):indtoofastpos(indpairs(k)+1),[X Y]) = nan;
    end

    % save this interpolated pos
    pos(:,[find(x) find(y)]) = tmppos(:, [X Y]);
    inds = tmppos(:,3);

end  % end invidual point computation

% Add an epsilon to any duplicates
epsilon = 1e4*eps(class(time));
duplicate = util.getduplicates(time);
if duplicate
    warning('Duplicate times')
    warn = "duplicate times";
end
time(duplicate) = time(duplicate) + cumsum(epsilon * ones(size(duplicate)))

if Opt.pinterp % Spline interpolate all nan'd points
    nanInds    = any(isnan(pos),2);
    nanLessTime = time(~nanInds);
    nanLessPos  = pos(~nanInds,2:end);
    nanTimes    = time(nanInds);
    nanPos = interp1(nanLessTime, nanLessPos, nanTimes, 'makima');
    pos(nanInds,2:end) = nanPos;
end

%% RY : I would prefer to keep pos the length of the video and not truncate
%% find the valid pos's according to the 'Opt.diode' variable
%if ischar(Opt.pointvalid) || isstring(Opt.pointvalid) || iscellstr(Opt.pointvalid)
%    Opt.pointvalid = string(Opt.pointvalid);
%    pointinds = ismember(pointNames, Opt.pointvalid);
%    indvalidpos = find(prod(pos(:,pointinds),2));
%else
%    indvalidpos = find(prod(pos(:,2:end),2));
%end
%
%% get the indeces of the first and last valid pos
%pvalidfirst = indvalidpos(1);
%pvalidlast  = indvalidpos(end);
%
%% truncate pos if there are zeros at the beginning and end
%pos  = pos(pvalidfirst:pvalidlast, :);
%time = time(pvalidfirst:pvalidlast,1);
%inds = inds(pvalidfirst:pvalidlast,1);

%====== DETERMINE WHICH POINTS FOR LEFT-RIGHT OR FRONT-BACK DIRECTION ===========
% Now we need to focus on direction, and to do so, identify which two points
% will form the animalk's direction
moreThanOnePoint = size(pos,2)-1 > 2; %More than just a single x,y tuple?
if moreThanOnePoint
    % IF user does not specify points that constitute direction, then find the first  front-back or left-rigth pair
    if isempty(Opt.directionPoints)
        % Determine if front-back or left-right exist
        if any(contains(pointNames, "front")) && any(contains(pointNames,"back"))
            pairPoints = 'front-back';
            P1 = pointNames(find(pointNames == "front", 1, 'first'));
            P2 = pointNames(find(pointNames == "back",  1, 'first'));
        elseif any(contains(pointNames, "left")) && any(contains(pointNames,"right"))
            pairPoints = 'left-right';
            P1 = pointNames(find(contains(pointNames,"left"),  1, 'first'));
            P2 = pointNames(find(contains(pointNames,"right"), 1, 'first'));
        else
            pairPoints = 'improper  type';
        end
    % Else the use has given points
    else
        Opt.directionPoints = string(Opt.directionPoints);
        P1 = Opt.directionPoints(1);
        P2 = Opt.directionPoints(2);
        % Has the user provided a type for these points?
        if isempty(Opt.directionPointType)
            if contains(P1,'front')
                pairPoints = 'front-back';
            elseif contains(P1,'left')
                pairPoints = 'left-right';
            else
                pairPoints = 'improper type';
            end
        else
            pairPoints = Opt.directionPointType;
        end
    end
else
    pairPoints = 'singular';
end

%====== COMPUTE THE UNDERLYING DIRECTION BASED ON THOSE POINTS ==================
% Compute direction based on front-back or left-right leds
switch pairPoints
case {'front-back', 'left-right'}
    [P1_x, P1_y, P2_x, P2_y ] = deal(pointNames==P1 & pointTypes == "x",...
                                     pointNames==P1 & pointTypes == "y",...
                                     pointNames==P2 & pointTypes == "x",...
                                     pointNames==P2 & pointTypes == "y");
    pointInds = {P1_x, P1_y, P2_x, P2_y };
    for i = 1:4
        for j = i+1:4
            assert(~isequal(pointInds{i}, pointInds{j}))
        end
    end
    if strcmp(pairPoints,'front-back')
        rotation_correction = 0;
    else
        rotation_correction = pi/2; % TODO TODO TODO rotate our vector -90 degrees to align with front-back
    end
    direction = atan2(pos(:,P1_x)-pos(:,P2_x), pos(:,P1_y)-pos(:,P2_y)) ...
                + rotation_correction;
    direction_complex = exp(1i*rotation_correction) * ((pos(:,P1_x)-pos(:,P2_x)) + 1i*(pos(:,P1_y)-pos(:,P2_y)));
case 'singular'
    direction = atan2(pos(:,pointNames~="timestamp" & pointTypes == "x"), ...
                      pos(:,pointNames~="timestamp" & pointTypes == "y"));
    direction_complex = [];
case 'improper type'
    disp('');
    error("ERROR: More than 1 point in deepLabCut, but cannot identify front-back or left-right points.  Please provide 'directionPointType' in your varargin");
end

% if the 'Opt.diode' variable was 1 or 0, then only the front or back Opt.diode,
% respectively, needed to be valid for pos.  for directions, however, both
% diodes should be valid, so do an additional check to see that both diodes
% were valid.
if ~isempty(Opt.midpoint) && Opt.midpoint>0 && Opt.midpoint<1
    indzerodir = any(isnan( pos(:,2:end) ),2);
    direction(indzerodir) = nan;
end

% now compute the final output pos, which can be anywhere including and
% between the front and back diodes.  this pos is determined by the 'Opt.diode'
% variable, with 0 being the back Opt.diode, 1 being the front Opt.diode, and any
% value in between being the proportionate distance between the two
if ~isempty(Opt.midpoint) && moreThanOnePoint
    pos(:,2) = pos(:,P1_x) + Opt.midpoint * (pos(:,P2_x)-pos(:,P1_x));
    pos(:,3) = pos(:,P1_y) + Opt.midpoint * (pos(:,P2_y)-pos(:,P1_y));
    pos = pos(:,2:3);
else
    pos = pos(:,2:end);
end

% take all of the valid position samples and the corresponding set of direction
% samples and save for the output
newpos.data              = [time pos direction];
newpos.rawposInds        = inds;
newpos.likelihood        = posdata.likelihood(inds,2:end);
newpos.likelihoodheader  = posdata.likelihoodheader(:,2:end);
newpos.direction_complex = direction_complex;
newpos.warn = warn;
